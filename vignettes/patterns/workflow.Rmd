---
title: "Workflow"
subtitle: "Sequential Steps"
bibliography: []
biblio-style: apalike
link-citations: yes
editor_options: 
  markdown: 
    wrap: 80
---

```{r, include = FALSE}
source(file.path(usethis::proj_get(), "vignettes",  "_common.R"))
path <- tempfile("docs-")
dir.create(path, F, T)
```

## What does `add_workflow` do?

Given the workflow name (order one pizza), the sub-domain name (pizza ordering)
and the number of steps in the workflow (3),

When `add_workflow` is called

```{r, eval = FALSE, echo = TRUE}
add_workflow(name = "order one pizza", domain = "pizza ordering", n_step = 3)
```

```{r, eval = TRUE, echo = FALSE}
withr::with_dir(
    path,
    add_workflow(name = "order-one-pizza", domain = "pizza ordering", n_step = 3)
)
file_path <- list.files(path, "order-one-pizza.R", recursive = TRUE)
```

Then the function:

-   Creates a workflow boilerplate with three steps;
-   Places the file under `r dirname(file_path)`; and
-   Opens the file (only in interactive mode).

## How to Move from Conception to Implementation?

In this section we customise the boilerplate code to fit the application design.

### Iteration 0

Before you call `add_workflow`, think about the process you are about to model.
Essentially, you need to decompose the process into a collection of tasks to run
and organise them in a way that reflect their relationships and dependencies.
For example, the tasks of fitting a linear model to data includes but not
limited to the next steps:

1.  Gather Data;
2.  Prepare Data;
3.  Train Model; and
4.  Evaluate Model.

These four tasks happen sequentially in the order of their writing. In this case
their order is irreversible, each task is dependent on its predecessors tasks.

Back to the package running example, ordering a pizza includes three steps:

1.  Issue new order;
2.  Order pizza; and
3.  Commit order.

We start be generating boilerplate code for a workflow that comprises three
steps:

```{r, eval = FALSE, echo = TRUE}
add_workflow(name = "order one pizza", domain = "pizza ordering", n_step = 3)
```

The boilerplate code produced by `add_workflow` looks likes this:

```{r code = readLines(fs::path(path, file_path)), eval=FALSE, echo=TRUE}
```

### Iteration 1

<!-- In this iteration we rename the generic names of the steps. Each step name, -->

<!-- should reveal you why the step exists, what it does and how it is used. What makes for a good step name? -->

<!-- If this is your first workflow in the project, strive to create as few elements -->

<!-- as possible, and yet have most of the different element types appear once. For -->

<!-- example, if your domain requires you to fit regression models to five target -->

<!-- variables, that is, you need five model objects, then start by modelling a -->

<!-- single model. Yet, include all the necessary steps to fit the single model. In -->

<!-- this case you may want to have the following steps: -->
