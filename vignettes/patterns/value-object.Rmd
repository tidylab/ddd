---
title: "Value Object"
bibliography: [../references.bib]
biblio-style: apalike
link-citations: yes
editor_options: 
  markdown: 
    wrap: 80
---

```{r, include = FALSE}
source(file.path(usethis::proj_get(), "vignettes",  "_common.R"))
path <- tempfile("docs-")
dir.create(path, F, T)
```

## Description

When you care only about the attributes of an element of the model, classify it
as a **Value Object**. Make it express the meaning of the attributes it conveys
and give it related functionality. Treat the **Value Object** as immutable.
Don't give it any identity and avoid the design complexities necessary to
maintain **Entities**. [@Evans2004, p. 99]

## Highlights

-   Calling a Value Object without any input arguments returns the Null Value
    Object, which is usually an empty data.frame with column names and classes.
-   Equating Value Objects is based on field-based implementation, rather than
    identity based implementation. That means, two records are equal if all
    their fields are equal.
-   Value Objects can receive other Value Objects.
-   Value Objects can receive one or a set of Entities.

## What does `add_value_object` do?

Given the value object name (Pizza Slip), and the sub-domain name (pizza
ordering),

When `add_value_object` is called

```{r, eval = FALSE, echo = TRUE}
add_value_object(name = "Pizza Slip", domain = "pizza ordering")
```

```{r, eval = TRUE, echo = FALSE}
name = "Pizza Slip"; domain = "pizza ordering"
withr::with_dir(path, add_value_object(name, domain))
file_path <- list.files(path, filename$value(name, domain), recursive = TRUE)
```

Then the function:

-   Creates a **Value Object** boilerplate with several input arguments;
-   Places the file at `r file_path`; and
-   Opens the file (only in interactive mode).

The boilerplate code produced by `add_value_object` looks likes this:

```{r code = readLines(fs::path(path, file_path)), eval=FALSE, echo=TRUE}
```

## Why should I use Value Objects in my desing?

The simplest way to implement a **Value Object** in R is with a function that
returns a data.frame row. Compare the following two patterns for creating a
data.frame that holds a pizza slip.

First, using the `tibble::tibble` function directly for constructing the pizza
slip

```{r, eval=FALSE, echo=TRUE}
slip <- tibble(size = "M", slices = 8, toppings = list(), takeaway = TRUE)
```

Second, using a **Value Object** as a surrogate for constructing the pizza slip

```{r, eval=FALSE, echo=TRUE}
slip <- PizzaSlip(size = "M", slices = 8, toppings = list(), takeaway = TRUE)
```

Both patterns return identical objects, equal in content and structure i.e.
column names and classes.

Why would one prefer using a **Value Object** over the direct alternative? There
are three apparent qualities offered by the **Value Object** pattern which are
not offered by the alternative:

-   Safety. Each input argument belongs to a certain class. This is guaranteed
    by type checking at the beginning of the function.

-   NULL **Value Object**. Calling the **Value Object** with no input arguments
    returns the structure of the `tibble` with default content, such as `NULL`,
    `NA` or actual values.

-   Default values for missing input arguments. In this manner, the **Value
    Object** has a well-defined behaviour for a pizza slip in a dining in only
    Pizzeria.

## References
